


ARM Macro Assembler    Page 1 


    1 00000000         
    2 00000000                 AREA             PROGRAM, CODE, READONLY
    3 00000000         
    4 00000000                 EXPORT           wrapper
    5 00000000                 ENTRY
    6 00000000         
    7 00000000         ;wrapper to the bcdadd routine that sends it operands an
                       d tests the returned sum
    8 00000000         wrapper
    9 00000000         ;test cases
   10 00000000         ;CASE 1: ro+, r1+
   11 00000000 495A            LDR              r1, =0x00762500
   12 00000002 485B            LDR              r0, =0x00309380
   13 00000004         
   14 00000004 F000 F841       BL               bcdadd
   15 00000008         
   16 00000008 4A5A            LDR              r2, =0x01071880
   17 0000000A 4290            CMP              r0, r2
   18 0000000C D13B            BNE              error
   19 0000000E         
   20 0000000E         ;CASE 2: r0-,r1-
   21 0000000E 495A            LDR              r1, =0x80039785
   22 00000010 485A            LDR              r0, =0x80139962
   23 00000012         
   24 00000012 F000 F83A       BL               bcdadd
   25 00000016         
   26 00000016 4A5A            LDR              r2, =0x80179747
   27 00000018 4290            CMP              r0, r2
   28 0000001A D134            BNE              error
   29 0000001C         
   30 0000001C         
   31 0000001C         ;CASE 3a: r0+, r1- (|ro|>|r1|)
   32 0000001C 4859            LDR              r0, =0x09656000
   33 0000001E 495A            LDR              r1, =0x87847000
   34 00000020         
   35 00000020 F000 F833       BL               bcdadd
   36 00000024         
   37 00000024 4A59            LDR              r2, =0x01809000
   38 00000026 4290            CMP              r0, r2
   39 00000028 D12D            BNE              error
   40 0000002A         
   41 0000002A         ;CASE 3b: r0+, r1- (|ro|<|r1|)
   42 0000002A 4859            LDR              r0, =0x07847000
   43 0000002C 4959            LDR              r1, =0x89656000
   44 0000002E         
   45 0000002E F000 F82C       BL               bcdadd
   46 00000032         
   47 00000032 4A59            LDR              r2, =0x81809000
   48 00000034 4290            CMP              r0, r2
   49 00000036 D126            BNE              error
   50 00000038         
   51 00000038         ;CASE 3c: r0+, r1- (|ro|=|r1|)
   52 00000038 4852            LDR              r0, =0x09656000
   53 0000003A 4956            LDR              r1, =0x89656000
   54 0000003C         
   55 0000003C F000 F825       BL               bcdadd
   56 00000040         
   57 00000040 F04F 0200       LDR              r2, =0x00000000
   58 00000044 4290            CMP              r0, r2



ARM Macro Assembler    Page 2 


   59 00000046 D11E            BNE              error
   60 00000048         
   61 00000048         
   62 00000048         ;CASE 4a: r0-, r1+ (|ro|>|r1|)
   63 00000048 4852            LDR              r0, =0x89656000
   64 0000004A 4951            LDR              r1, =0x07847000
   65 0000004C         
   66 0000004C F000 F81D       BL               bcdadd
   67 00000050         
   68 00000050 4A51            LDR              r2, =0x81809000
   69 00000052 4290            CMP              r0, r2
   70 00000054 D117            BNE              error
   71 00000056         
   72 00000056         ;CASE 4b: r0-, r1+ (|ro|<|r1|)
   73 00000056 484C            LDR              r0, =0x87847000
   74 00000058 494A            LDR              r1, =0x09656000
   75 0000005A         
   76 0000005A F000 F816       BL               bcdadd
   77 0000005E         
   78 0000005E 4A4B            LDR              r2, =0x01809000
   79 00000060 4290            CMP              r0, r2
   80 00000062 D110            BNE              error
   81 00000064         
   82 00000064         ;CASE 4c: r0-, r1+ (|ro|=|r1|)
   83 00000064 484B            LDR              r0, =0x89656000
   84 00000066 4947            LDR              r1, =0x09656000
   85 00000068         
   86 00000068 F000 F80F       BL               bcdadd
   87 0000006C         
   88 0000006C F04F 0200       LDR              r2, =0x00000000
   89 00000070 4290            CMP              r0, r2
   90 00000072 D108            BNE              error
   91 00000074         
   92 00000074         ;CASE 5: r0 , r1 have an overflow to start with
   93 00000074 4849            LDR              r0, =0xF9656000
   94 00000076 4943            LDR              r1, =0x09656000
   95 00000078         
   96 00000078 F000 F807       BL               bcdadd
   97 0000007C         
   98 0000007C F04F 5240       LDR              r2, =0x30000000
   99 00000080 4290            CMP              r0, r2
  100 00000082 D100            BNE              error
  101 00000084         
  102 00000084 E000            B                success
  103 00000086         
  104 00000086 E7FE    error   B                error
  105 00000088         
  106 00000088 E7FE    success B                success
  107 0000008A         
  108 0000008A         
  109 0000008A         
  110 0000008A         
  111 0000008A         
  112 0000008A         
  113 0000008A         ;bcdadd routine, takes two well formatted BCDs in r0 and
                        r1, and places their BCD sum in r0
  114 0000008A         bcdadd
  115 0000008A B500            push             {LR}
  116 0000008C         



ARM Macro Assembler    Page 3 


  117 0000008C         ;determine if any of r0 and r1 have an overflow
  118 0000008C F010 4F80       TST              r0, #0x40000000
  119 00000090 D138            BNE              overflow
  120 00000092 F011 4F80       TST              r1, #0x40000000
  121 00000096 D135            BNE              overflow
  122 00000098         
  123 00000098         ;determine sign of r0
  124 00000098 F010 4F00       TST              r0, #0x80000000
  125 0000009C D100            BNE              r0Negative
  126 0000009E E003            B                r0Positive
  127 000000A0         
  128 000000A0         r0Negative
  129 000000A0         ;determine sign of r1
  130 000000A0 F011 4F00       TST              r1, #0x80000000
  131 000000A4 D107            BNE              r0N_r1N
  132 000000A6 E00B            B                r0N_r1P
  133 000000A8         
  134 000000A8         r0Positive
  135 000000A8         ;determine sign of r1
  136 000000A8 F011 4F00       TST              r1, #0x80000000
  137 000000AC D11C            BNE              r0P_r1N
  138 000000AE E7FF            B                r0P_r1P
  139 000000B0         
  140 000000B0         ;CASE 1: r0 Positive, r1 Positive 
  141 000000B0         r0P_r1P
  142 000000B0 F000 F838       BL               add
  143 000000B4 E01C            B                checkOverflow ;check overflow o
                                                            nly if r0 and r1 ar
                                                            e both same sign
  144 000000B6         
  145 000000B6         ;CASE 2: r0 Negative, r1 Negative
  146 000000B6         r0N_r1N
  147 000000B6 F000 F835       BL               add
  148 000000BA F040 4000       ORR              r0, #0x80000000 ;set the negati
                                                            ve bit
  149 000000BE E017            B                checkOverflow ;check overflow o
                                                            nly if r0 and r1 ar
                                                            e both same sign
  150 000000C0         
  151 000000C0         ;CASE 3a: r0 Negative, r1 Positive (r1>=|r0|)
  152 000000C0         r0N_r1P
  153 000000C0 F020 4070       AND              r0, #0x0fffffff ;clear last nib
                                                            ble since now we've
                                                             already processed 
                                                            overflow and sign f
                                                            lags
  154 000000C4 F021 4170       AND              r1, #0x0fffffff
  155 000000C8         
  156 000000C8 4288            CMP              r0, r1      ;moved comparison b
                                                            efore the first ten
                                                            sComplement (didn't
                                                             work after)
  157 000000CA DC04            BGT              r0N_r1P_GT
  158 000000CC         
  159 000000CC F000 F81F       BL               tensComplement
  160 000000D0 F000 F828       BL               add         ;r1 needs to be lar
                                                            ger than or equal t
                                                            o r0 (before comple
                                                            ment operation) for



ARM Macro Assembler    Page 4 


                                                             the result to be p
                                                            ositive
  161 000000D4 E011            B                stop
  162 000000D6         
  163 000000D6         ;CASE 3b: r0 Negative, r1 Positive (r1<|r0|)
  164 000000D6         r0N_r1P_GT
  165 000000D6 F000 F81A       BL               tensComplement
  166 000000DA F000 F823       BL               add
  167 000000DE F000 F816       BL               tensComplement
  168 000000E2         ;add negative sign to result
  169 000000E2 F040 4000       ORR              r0, #0x80000000 ;set the negati
                                                            ve bit 
  170 000000E6 E008            B                stop
  171 000000E8         
  172 000000E8         ;CASE 4: r0 Positive, r1 Negative
  173 000000E8         r0P_r1N
  174 000000E8         ;swap and call case 3
  175 000000E8 460A            MOV              r2, r1
  176 000000EA 4601            MOV              r1, r0
  177 000000EC 4610            MOV              r0, r2
  178 000000EE E7E7            B                r0N_r1P
  179 000000F0         
  180 000000F0         
  181 000000F0         ;normal exits
  182 000000F0         checkOverflow
  183 000000F0         ;determine if overflow, and set overflow bit if the case
                       
  184 000000F0 F010 5F80       TST              r0,#0x10000000
  185 000000F4 BF18 F040 
              4080             ORRNE            r0,#0x40000000 ;set the overflo
                                                            w bit if there was 
                                                            an overflow
  186 000000FA         
  187 000000FA         stop
  188 000000FA         ;clear don't care bits for uniformity
  189 000000FA F020 5040       AND              r0, #0xCFFFFFFF
  190 000000FE         
  191 000000FE F85D EB04       pop              {LR}
  192 00000102 4770            BX               LR
  193 00000104         
  194 00000104         ;abnormal exits
  195 00000104         overflow
  196 00000104 F04F 5040       LDR              r0, =0x30000000 ;return special
                                                             value if passed va
                                                            lues have overflow 
                                                            to begin with
  197 00000108         
  198 00000108 F85D EB04       pop              {LR}
  199 0000010C 4770            BX               LR
  200 0000010E         
  201 0000010E         
  202 0000010E         
  203 0000010E         
  204 0000010E         
  205 0000010E         
  206 0000010E         
  207 0000010E         
  208 0000010E         ;computes tensComplement of r0 and stores it in r0
  209 0000010E         ;assumes properly formatted BCD in r0



ARM Macro Assembler    Page 5 


  210 0000010E         tensComplement
  211 0000010E B502            push             {r1,LR}
  212 00000110         
  213 00000110         ;constructing the number #0x09999999
  214 00000110 4A23            LDR              r2, =0x09999999
  215 00000112         
  216 00000112         ;9's complement
  217 00000112 EBC0 0002       RSB              r0, r0, r2
  218 00000116         
  219 00000116         ;add one using our adder routine
  220 00000116 F04F 0101       MOV              r1, #1
  221 0000011A F000 F803       BL               add
  222 0000011E         
  223 0000011E E8BD 4002       pop              {r1,LR}
  224 00000122 4770            BX               LR
  225 00000124         
  226 00000124         
  227 00000124         
  228 00000124         
  229 00000124         
  230 00000124         
  231 00000124         
  232 00000124         
  233 00000124         ;assumes well formatted BCDs (i.e. no nibble over 9)
  234 00000124         ;adds +ve BCDs of 7 nibbles stored in r0 and r1 and retu
                       rns result in r0
  235 00000124         add
  236 00000124 B4FC            push             {r2-r7}     ;save context of us
                                                            ed scratch register
                                                            s
  237 00000126         
  238 00000126 F04F 0400       MOV              r4, #0      ;r4 will contain th
                                                            e result
  239 0000012A F04F 0300       MOV              r3, #0      ;r2 and r3 are for 
                                                            additions (r3 conta
                                                            ins result)
  240 0000012E F04F 0200       MOV              r2, #0
  241 00000132         
  242 00000132         ;values used for special purposes (shifted left after ev
                       ery nibble addition)
  243 00000132 F04F 050F       MOV              r5, #0x0000000f ;used as mask t
                                                            o extract nibble
  244 00000136 F04F 0609       MOV              r6, #0x00000009 ;used to determ
                                                            ine if sum greater 
                                                            than 9
  245 0000013A F04F 0706       MOV              r7, #0x00000006 ;used to add 6 
                                                            to a sum if greater
                                                             than 9
  246 0000013E         
  247 0000013E         nibble_add_loop
  248 0000013E         ;isolate the nimbles to be added
  249 0000013E EA00 0205       AND              r2, r0, r5
  250 00000142 EA01 0305       AND              r3, r1, r5
  251 00000146         
  252 00000146         ;add the isolated nibbles
  253 00000146 4413            ADD              r3, r2, r3
  254 00000148         
  255 00000148         ;add the new nibble sum to the overall sum
  256 00000148 441C            ADD              r4, r4, r3



ARM Macro Assembler    Page 6 


  257 0000014A         
  258 0000014A 42B4            CMP              r4, r6      ;perform comparison
                                                             here in order to i
                                                            nclude carry from p
                                                            revious nibble add 
                                                            
  259 0000014C BFC8 443C       ADDGT            r4, r7
  260 00000150         
  261 00000150         ;shifting of special values
  262 00000150         ;note that shifting is not done during operation (using 
                       barrel shifter) because the shifted value is not persist
                       ed
  263 00000150 EA4F 1505       LSL              r5, #4
  264 00000154 EA4F 1606       LSL              r6, #4      ;shift of r6 replic
                                                            ates the 9's for co
                                                            mparison purposes w
                                                            ith r4
  265 00000158 F106 0609       ADD              r6, #9
  266 0000015C EA4F 1707       LSL              r7, #4
  267 00000160         
  268 00000160         ;determine if we need to pursue adding nibbles
  269 00000160 F1B5 4F70       CMP              r5, #0xf0000000
  270 00000164 D1EB            BNE              nibble_add_loop ;when the compa
                                                            rison produces a re
                                                            sult of 0, don't br
                                                            anch again
  271 00000166         
  272 00000166 4620            MOV              r0, r4      ;store result in r0
                                                            
  273 00000168 BCFC            pop              {r2-r7}     ;restore context
  274 0000016A         
  275 0000016A 4770            BX               LR
  276 0000016C         
  277 0000016C                 END
              00762500 
              00309380 
              01071880 
              80039785 
              80139962 
              80179747 
              09656000 
              87847000 
              01809000 
              07847000 
              89656000 
              81809000 
              F9656000 
              09999999 
Command Line: --debug --xref --cpu=Cortex-M3 --apcs=interwork --depend=bcdadd.d
 -obcdadd.o -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\INC\ST\STM32F10x --predef
ine="__EVAL SETA 1" --list=bcdadd.lst bcdadd.s



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
Relocatable symbols

PROGRAM 00000000

Symbol: PROGRAM
   Definitions
      At line 2 in file bcdadd.s
   Uses
      None
Comment: PROGRAM unused
add 00000124

Symbol: add
   Definitions
      At line 235 in file bcdadd.s
   Uses
      At line 142 in file bcdadd.s
      At line 147 in file bcdadd.s
      At line 160 in file bcdadd.s
      At line 166 in file bcdadd.s
      At line 221 in file bcdadd.s

bcdadd 0000008A

Symbol: bcdadd
   Definitions
      At line 114 in file bcdadd.s
   Uses
      At line 14 in file bcdadd.s
      At line 24 in file bcdadd.s
      At line 35 in file bcdadd.s
      At line 45 in file bcdadd.s
      At line 55 in file bcdadd.s
      At line 66 in file bcdadd.s
      At line 76 in file bcdadd.s
      At line 86 in file bcdadd.s
      At line 96 in file bcdadd.s

checkOverflow 000000F0

Symbol: checkOverflow
   Definitions
      At line 182 in file bcdadd.s
   Uses
      At line 143 in file bcdadd.s
      At line 149 in file bcdadd.s

error 00000086

Symbol: error
   Definitions
      At line 104 in file bcdadd.s
   Uses
      At line 18 in file bcdadd.s
      At line 28 in file bcdadd.s
      At line 39 in file bcdadd.s
      At line 49 in file bcdadd.s
      At line 59 in file bcdadd.s
      At line 70 in file bcdadd.s
      At line 80 in file bcdadd.s
      At line 90 in file bcdadd.s



ARM Macro Assembler    Page 2 Alphabetic symbol ordering
Relocatable symbols

      At line 100 in file bcdadd.s
      At line 104 in file bcdadd.s

nibble_add_loop 0000013E

Symbol: nibble_add_loop
   Definitions
      At line 247 in file bcdadd.s
   Uses
      At line 270 in file bcdadd.s
Comment: nibble_add_loop used once
overflow 00000104

Symbol: overflow
   Definitions
      At line 195 in file bcdadd.s
   Uses
      At line 119 in file bcdadd.s
      At line 121 in file bcdadd.s

r0N_r1N 000000B6

Symbol: r0N_r1N
   Definitions
      At line 146 in file bcdadd.s
   Uses
      At line 131 in file bcdadd.s
Comment: r0N_r1N used once
r0N_r1P 000000C0

Symbol: r0N_r1P
   Definitions
      At line 152 in file bcdadd.s
   Uses
      At line 132 in file bcdadd.s
      At line 178 in file bcdadd.s

r0N_r1P_GT 000000D6

Symbol: r0N_r1P_GT
   Definitions
      At line 164 in file bcdadd.s
   Uses
      At line 157 in file bcdadd.s
Comment: r0N_r1P_GT used once
r0Negative 000000A0

Symbol: r0Negative
   Definitions
      At line 128 in file bcdadd.s
   Uses
      At line 125 in file bcdadd.s
Comment: r0Negative used once
r0P_r1N 000000E8

Symbol: r0P_r1N
   Definitions
      At line 173 in file bcdadd.s
   Uses



ARM Macro Assembler    Page 3 Alphabetic symbol ordering
Relocatable symbols

      At line 137 in file bcdadd.s
Comment: r0P_r1N used once
r0P_r1P 000000B0

Symbol: r0P_r1P
   Definitions
      At line 141 in file bcdadd.s
   Uses
      At line 138 in file bcdadd.s
Comment: r0P_r1P used once
r0Positive 000000A8

Symbol: r0Positive
   Definitions
      At line 134 in file bcdadd.s
   Uses
      At line 126 in file bcdadd.s
Comment: r0Positive used once
stop 000000FA

Symbol: stop
   Definitions
      At line 187 in file bcdadd.s
   Uses
      At line 161 in file bcdadd.s
      At line 170 in file bcdadd.s

success 00000088

Symbol: success
   Definitions
      At line 106 in file bcdadd.s
   Uses
      At line 102 in file bcdadd.s
      At line 106 in file bcdadd.s

tensComplement 0000010E

Symbol: tensComplement
   Definitions
      At line 210 in file bcdadd.s
   Uses
      At line 159 in file bcdadd.s
      At line 165 in file bcdadd.s
      At line 167 in file bcdadd.s

wrapper 00000000

Symbol: wrapper
   Definitions
      At line 8 in file bcdadd.s
   Uses
      At line 4 in file bcdadd.s
Comment: wrapper used once
18 symbols
344 symbols in table
